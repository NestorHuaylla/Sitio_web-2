import React, { useState, useEffect, useRef, useMemo } from 'react';
import { Play, Pause, RefreshCw, MousePointer2 } from 'lucide-react';

const GameOfLifeNetwork3D = () => {
  // --- Configuración ---
  const [isPlaying, setIsPlaying] = useState(true);
  const [frameCount, setFrameCount] = useState(0); 
  const [dimensions, setDimensions] = useState({ width: 0, height: 0, cols: 0, rows: 0, centerX: 0, centerY: 0 });
  
  // --- Ajustes visuales y 3D ---
  const NODE_SPACING_BASE = 80; 
  const TUNNEL_DEPTH = 3000; 
  const FOCAL_LENGTH = 600; 
  const TRAVEL_SPEED = 20; 

  // --- Referencias de Animación y Cámara ---
  const gridRef = useRef([]);
  const requestRef = useRef();
  const containerRef = useRef(null);
  
  const cameraZRef = useRef(0); 

  // --- Paleta de Colores ---
  const COLORS = {
    birth: '#00ff66', // Verde neón
    stable: '#00d2ff', // Azul eléctrico
    dying: '#ff0033', // Rojo neón
    background: '#000000' // Fondo Negro Puro para máximo contraste
  };

  const initGrid = (cols, rows, random = true) => {
    const newGrid = [];
    const centerCol = cols / 2;
    const centerRow = rows / 2;

    for (let i = 0; i < cols; i++) {
      newGrid[i] = [];
      for (let j = 0; j < rows; j++) {
        const baseX = (i - centerCol) * NODE_SPACING_BASE;
        const baseY = (j - centerRow) * NODE_SPACING_BASE;
        
        newGrid[i][j] = {
          active: random ? Math.random() > 0.92 : false,
          age: 0,
          dying: false,
          baseX: baseX,
          baseY: baseY,
          baseZ: Math.random() * TUNNEL_DEPTH 
        };
      }
    }
    return newGrid;
  };

  useEffect(() => {
    const handleResize = () => {
      if (containerRef.current) {
        const { clientWidth, clientHeight } = containerRef.current;
        const cols = Math.ceil(clientWidth / NODE_SPACING_BASE) * 2;
        const rows = Math.ceil(clientHeight / NODE_SPACING_BASE) * 2;
        
        setDimensions({ 
            width: clientWidth, 
            height: clientHeight, 
            cols, 
            rows,
            centerX: clientWidth / 2,
            centerY: clientHeight / 2
        });
        gridRef.current = initGrid(cols, rows, true);
        cameraZRef.current = 0;
      }
    };

    window.addEventListener('resize', handleResize);
    setTimeout(handleResize, 100); 

    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const computeNextGeneration = () => {
    const currentGrid = gridRef.current;
    const { cols, rows } = dimensions;
    if (cols === 0 || rows === 0) return;

    const nextGrid = currentGrid.map(col => col.map(cell => ({ ...cell })));
    let activeCount = 0; 

    for (let i = 0; i < cols; i++) {
      for (let j = 0; j < rows; j++) {
        const cell = currentGrid[i][j];
        let neighbors = 0;
        for (let x = -1; x <= 1; x++) {
          for (let y = -1; y <= 1; y++) {
            if (x === 0 && y === 0) continue;
            const ni = (i + x + cols) % cols;
            const nj = (j + y + rows) % rows;
            if (currentGrid[ni][nj].active) neighbors++;
          }
        }

        // Aplicar reglas
        if (cell.active) {
          if (neighbors < 2 || neighbors > 3) {
            nextGrid[i][j].active = false;
            nextGrid[i][j].dying = true;
            nextGrid[i][j].age = 0;
          } else {
            nextGrid[i][j].active = true; 
            nextGrid[i][j].age += 1;
            nextGrid[i][j].dying = false;
          }
        } else {
          if (neighbors === 3) {
            nextGrid[i][j].active = true;
            nextGrid[i][j].dying = false;
            nextGrid[i][j].age = 0;
          } else {
            if (cell.dying) nextGrid[i][j].dying = false;
          }
        }

        if (nextGrid[i][j].active) {
            activeCount++;
        }
      }
    }

    // Lógica de rescate
    if (activeCount <= 4) {
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                if (!nextGrid[i][j].active && Math.random() > 0.90) {
                    nextGrid[i][j].active = true;
                    nextGrid[i][j].age = 0;
                    nextGrid[i][j].dying = false;
                }
            }
        }
    }

    gridRef.current = nextGrid;
  };

  useEffect(() => {
    let lastGolUpdate = 0;
    const animate = (time) => {
      if (isPlaying) {
        cameraZRef.current += TRAVEL_SPEED;

        if (time - lastGolUpdate > 200) { 
          computeNextGeneration();
          lastGolUpdate = time;
        }
        
        setFrameCount(c => c + 1);
      }
      requestRef.current = requestAnimationFrame(animate);
    };

    requestRef.current = requestAnimationFrame(animate);
    return () => cancelAnimationFrame(requestRef.current);
  }, [isPlaying, dimensions]);

  const project3Dto2D = (baseX, baseY, baseZ) => {
    let relativeZ = (baseZ - cameraZRef.current) % TUNNEL_DEPTH;
    if (relativeZ <= 0) relativeZ += TUNNEL_DEPTH;

    if (relativeZ < FOCAL_LENGTH / 10) return null; 

    const scale = FOCAL_LENGTH / relativeZ;
    const screenX = dimensions.centerX + baseX * scale;
    const screenY = dimensions.centerY + baseY * scale;
    const opacity = Math.min(1, (TUNNEL_DEPTH - relativeZ) / (TUNNEL_DEPTH * 0.6));

    return { x: screenX, y: screenY, scale, opacity, zIndex: relativeZ };
  };

  const renderSVGContent = useMemo(() => {
    const nodes = [];
    const edges = [];
    const { cols, rows } = dimensions;
    if (cols === 0) return { nodes: [], edges: [] };

    const renderQueue = [];

    for (let i = 0; i < cols; i++) {
      for (let j = 0; j < rows; j++) {
        const cell = gridRef.current[i]?.[j];
        if (!cell || (!cell.active && !cell.dying)) continue;

        const projection = project3Dto2D(cell.baseX, cell.baseY, cell.baseZ);
        if (!projection) continue;

        renderQueue.push({ ...cell, ...projection, gridIdx: {i, j} });
      }
    }

    renderQueue.sort((a, b) => b.zIndex - a.zIndex);

    renderQueue.forEach(item => {
      let fill = COLORS.stable;
      const uniformBaseRadius = 8; 

      if (item.active) {
        if (item.age <= 1) {
          fill = COLORS.birth;
        }
      } else if (item.dying) {
        fill = COLORS.dying;
      }

      const finalRadius = uniformBaseRadius * item.scale;

      nodes.push(
        <circle
          key={`n-${item.gridIdx.i}-${item.gridIdx.j}`}
          cx={item.x}
          cy={item.y}
          r={Math.max(0.5, finalRadius)}
          fill={fill}
          opacity={item.opacity}
          filter="url(#glow)"
        />
      );

      if (item.active && item.scale > 0.2) {
        [[1,0], [0,1]].forEach(([dx, dy]) => {
            const ni = (item.gridIdx.i + dx + cols) % cols;
            const nj = (item.gridIdx.j + dy + rows) % rows;
            const neighbor = gridRef.current[ni][nj];
            
            if (neighbor && neighbor.active) {
                 const nProj = project3Dto2D(neighbor.baseX, neighbor.baseY, neighbor.baseZ);
                 if (nProj && Math.abs(nProj.zIndex - item.zIndex) < TUNNEL_DEPTH / 2) {
                    edges.push(
                    <line
                      key={`e-${item.gridIdx.i}-${item.gridIdx.j}-${ni}-${nj}`}
                      x1={item.x} y1={item.y}
                      x2={nProj.x} y2={nProj.y}
                      stroke={COLORS.stable}
                      strokeWidth={Math.max(0.5, 2 * item.scale)}
                      opacity={Math.min(item.opacity, nProj.opacity) * 0.4}
                    />
                  );
                 }
            }
        });
      }
    });

    return { nodes, edges };
  }, [dimensions, frameCount]); 

  const handleInteraction = () => {
     gridRef.current = initGrid(dimensions.cols, dimensions.rows, true);
  };

  return (
    <div className="relative w-full h-screen overflow-hidden bg-black font-sans" style={{backgroundColor: COLORS.background}}>
      <div 
        ref={containerRef}
        className="absolute inset-0 z-0"
        onClick={handleInteraction}
      >
        <svg width="100%" height="100%" className="block" style={{perspective: '1000px'}}>
          <defs>
            <filter id="glow" x="-100%" y="-100%" width="300%" height="300%">
              <feGaussianBlur stdDeviation="4" result="coloredBlur" />
              <feGaussianBlur stdDeviation="8" result="softBlur" />
               <feMerge>
                 <feMergeNode in="softBlur" />
                 <feMergeNode in="coloredBlur" />
                 <feMergeNode in="SourceGraphic" />
               </feMerge>
            </filter>
          </defs>
          <g>{renderSVGContent.edges}</g>
          <g>{renderSVGContent.nodes}</g>
        </svg>
      </div>

      <div className="absolute bottom-6 left-6 z-10 bg-slate-900/60 backdrop-blur-md border border-slate-800 p-4 rounded-xl shadow-2xl text-white pointer-events-none select-none">
        <h1 className="text-lg font-bold mb-2 bg-gradient-to-r from-green-400 to-blue-500 bg-clip-text text-transparent">
          Red Neuronal 3D
        </h1>
        <div className="flex gap-2 mb-3 text-xs font-medium">
          <span className="px-2 py-1 rounded bg-green-500/20 text-green-400 border border-green-500/30">● Generación</span>
          <span className="px-2 py-1 rounded bg-red-600/20 text-red-500 border border-red-500/30">● Destrucción</span>
        </div>

        <div className="flex gap-2 pointer-events-auto">
          <button 
            onClick={() => setIsPlaying(!isPlaying)}
            className="p-2 bg-slate-800 hover:bg-slate-700 rounded-lg transition-colors"
          >
            {isPlaying ? <Pause size={18} /> : <Play size={18} />}
          </button>
          <button 
            onClick={handleInteraction}
            className="p-2 bg-slate-800 hover:bg-slate-700 rounded-lg transition-colors text-blue-400"
          >
            <RefreshCw size={18} />
          </button>
           <span className="text-xs text-slate-500 flex items-center ml-2">
            <MousePointer2 size={12} className="mr-1"/> Clic para regenerar
          </span>
        </div>
      </div>
    </div>
  );
};

export default GameOfLifeNetwork3D;